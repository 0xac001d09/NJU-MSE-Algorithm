## 

# 第一次测验

## 第一题

![image-20190926225137141](/Users/zhangye/Library/Application%20Support/typora-user-images/image-20190926225137141.png)



**Description**

Given an array of integers, sort the array according to frequency of elements. For example, if the input array is {2, 3, 2, 4, 5, 12, 2, 3, 3, 3, 12}, then modify the array to {3, 3, 3, 3, 2, 2, 2, 12, 12, 4, 5}. If frequencies of two elements are same, print them in increasing order.

**Input**

The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows. The first line of each test case contains a single integer N denoting the size of array. The second line contains N space-separated integers A1, A2,..., AN denoting the elements of the array.（1 ≤ T ≤ 70；30 ≤ N ≤ 130 ）

**Output**

Print each sorted array in a seperate line. For each array its numbers should be seperated by space.

## 第二题

![image-20190926225523408](/Users/zhangye/Library/Application%20Support/typora-user-images/image-20190926225523408.png)

**Description**

Given an array of N distinct elementsA[ ], find the minimum number of swaps required to sort the array.Your are required to complete the function which returns an integer denoting the minimum number of swaps, required to sort the array.

**Input**

The first line of input contains an integer T denoting the no of test cases . Then T test cases follow . Each test case contains an integer N denoting the no of element of the array A[ ]. In the next line are N space separated values of the array A[ ] .

**Output**

For each test case in a new line output will be an integer denoting minimum umber of swaps that are required to sort the array.

思路：

- 对于数组 A[i] ，如果 A[i] 在正确位置上，则跳过，若A [i] 不在正确的位置上，假设它的正确位置位 j，那么 A[i] 和 A[j] 交换，此时 A[i] 到达正确的位置，而 i 位置上的元素为A[j]，如果A[j]也是在正确的位置上，则停止，否则继续让A[j]寻找正确的位置，直至找到。

- 例如

  - 遍历数组[1，5，4，3，2]

    1在正确的位置上，跳过

    5不在正确的位置上，它和2交换，变为[1,2,4,3,5],此时5到了正确的位置，2也在正确的位置，停止。

    4不在正确的位置上，它和3交换，3交换后也到了排序后的正确的位置，停止。

- 循环节

  - 在一次操作中，把该次操作的所有元素都放到正确位置上的操作所形成的环

  - 比如数组[7,1,3,2,4,5,6]

    ​	7和6交换[6,1,3,2,4,5,7]

    ​	6和5交换[5,1,3,2,4,6,7]

    ​	5和4交换[4,1,3,2,5,6,7]

    ​	4和2交换[2,1,3,4,5,6,7]

    ​	2和1交换[1,2,3,4,5,6,7]

    这样形成一个环[7,6,5,4,2,1],3不在其中，因为3在正确的位置上

## 第三题

按照另一个数组排序（相对排序）

![image-20190926225643387](/Users/zhangye/Library/Application%20Support/typora-user-images/image-20190926225643387.png)

**Description**

Given two array A1[] and A2[], sort A1 in such a way that the relative order among the elements will be same as those in A2. For the elements not present in A2. Append them at last in sorted order. It is also given that the number of elements in A2[] are smaller than or equal to number of elements in A1[] and A2[] has all distinct elements.

Input:A1[] = {2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8} A2[] = {2, 1, 8, 3} Output: A1[] = {2, 2, 1, 1, 8, 8, 3, 5, 6, 7, 9}

Since 2 is present first in A2[], all occurrences of 2s should appear first in A[], then all occurrences 1s as 1 comes after 2 in A[]. Next all occurrences of 8 and then all occurrences of 3. Finally we print all those elements of A1[] that are not present in A2[]

**Input**

The first line of input contains an integer T denoting the number of test cases. The first line of each test case is M and N. M is the number of elements in A1 and N is the number of elements in A2.The second line of each test case contains M elements. The third line of each test case contains N elements.

**Output**

Print the sorted array according order defined by another array.



## 第四题

![image-20190926225713074](/Users/zhangye/Library/Application%20Support/typora-user-images/image-20190926225713074.png)

思路：

逆序是说a[i]>a[j]，i<j。那么在排序的过程中，会把a[i]和a[j]交换过来，这个交换的过程，每交换一次，就是一个逆序对的“正序”过程。利用分治的思想：先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数（也就是逆序数），这三个过程加起来就是整体的逆序数目了。归并排序的思想就是把前一段排序，后一段排序，然后再整体排序。而且，归并排序的规程中，需要判断前一半数组和后一半数组中当前数字的大小。这也就是刚刚描述的逆序的判断过程了。如果前一半数组的当前数字大于后一半数组的当前数字，那么这就是一个逆序数。



# 第一次作业

## 第一题



![image-20191017202543500](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202543500.png)

Description

给定数组arr和整数num，求arr的连续子数组中满足：其最大值减去最小值的结果大于num的个数。请实现一个时间复杂度为O(length(arr))的算法。

Input

输入第一行为测试用例个数。每一个用例有若干行，第一行为数组，每一个数用空格隔开，第二行为num。

Output

输出一个值。

Sample Input 1 

```
1
3 6 4 3 2
2
```

Sample Output 1

```
6
```

## 第二题

![image-20191017202627889](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202627889.png)

Description

给定一个矩形区域，每一个位置上都是1或0，求该矩阵中每一个位置上都是1的最大子矩形区域中的1的个数。

Input

输入第一行为测试用例个数。每一个用例有若干行，第一行为矩阵行数n和列数m，下面的n行每一行是用空格隔开的0或1。

Output

输出一个数值。

Sample Input 1 

```
1
3 4
1 0 1 1
1 1 1 1
1 1 1 0
```

Sample Output 1

```
6
```

## 第三题

![image-20191017202720670](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202720670.png)

Description

给定一个整型数组arr和一个大小为w的窗口，窗口从数组最左边滑动到最右边，每次向右滑动一个位置，求出每一次滑动时窗口内最大元素的和。

Input

输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个元素使用空格隔开；第二行为窗口大小。

Output

输出每个测试用例结果。

Sample Input 1 

```
1
4 3 5 4 3 3 6 7
3
```

Sample Output 1

```
32
```

## 第四题

![image-20191017202744325](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202744325.png)

Description

汉诺塔问题中限制不能将一层塔直接从最左侧移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间。求当有N层塔的时候移动步数。

Input

输入第一行为用例个数， 每个测试用例输入的第一行为N。

Output

移动步数。

Sample Input 1 

```
1
2
```

Sample Output 1

```
8
```

## 第五题

![image-20191017202807169](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202807169.png)

Description

找到给定数组的给定区间内的第K小的数值。

Input

输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个数用空格隔开；第二行是区间（第几个数到第几个数，两头均包含），两个值用空格隔开；第三行为K值。

Output

结果。

Sample Input 1 

```
1
1 2 3 4 5 6 7
3 5
2
```

Sample Output 1

```
4
```

## 第六题

![image-20191017202831076](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202831076.png)

Description

输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，统计这样两个数的对数。

Input

输入第一行为用例个数， 每个测试用例输入第一行是数组，每一个数用空格隔开；第二行是数字和。

Output

输出这样两个数有几对。

Sample Input 1 

```
1
1 2 4 7 11 0 9 15
11
```

Sample Output 1

```
3
```

## 第七题

![image-20191017202854242](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202854242.png)

先升后降

Description

从一列不重复的数中筛除尽可能少的数使得从左往右看，这些数是从小到大再从大到小的。

Input

输入第一行为用例个数， 每个测试用例输入是一个数组，数值通过空格隔开。

Output

输出筛选之后的数组，用空格隔开。如果有多种结果，则一行一种结果， 单个输入的所有结果按从小到大排序，排序的key的优先级随index递增而递减 例如 3 4 7 6； 1 3 7 5； 1 2 7 6； 1 3 7 6 排序成 1 2 7 6；1 3 7 5；1 3 7 6； 3 4 7 6；

Sample Input 1 

```
4
1 2 4 7 11 10 9 15 3 5 8 6
1 3 5 4 7 6 4 5 3
1 2 3
3 2 1
```

Sample Output 1

```
1 2 4 7 11 10 9 8 6
1 3 4 7 6 4 3
1 3 4 7 6 5 3
1 3 5 7 6 4 3
1 3 5 7 6 5 3
1 2 3
3 2 1
```

## 第八题

![image-20191017202915986](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017202915986.png)

Description

有两个序列 a,b，大小都为 n,序列元素的值任意整数，无序； 要求：通过交换 a,b 中的元素，使[序列 a 元素的和]与[序列 b 元素的和]之间的差最小。

Input

输入第一行为用例个数， 每个测试用例输入为两行，分别为两个数组，每个值用空格隔开。

Output

输出变化之后的两个数组内元素和的差绝对值。

Sample Input 1 

```
1
100 99 98 1 2 3
1 2 3 4 5 40
```

Sample Output 1

```
48
```

# 第二次测验（A班）

##第一题

![image-20191017203003535](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203003535.png)

Description

Implement pow(A, B) % C.In other words, given A, B and C, find (A^B)%C

Input

The first line of input consists number of the test cases. The following T lines consist of 3 numbers each separated by a space and in the following order:A B C'A' being the base number, 'B' the exponent (power to the base number) and 'C' the modular.Constraints:1 ≤ T ≤ 70,1 ≤ A ≤ 10^5,1 ≤ B ≤ 10^5,1 ≤ C ≤ 10^5

Output

In each separate line print the modular exponent of the given numbers in the test case.

Sample Input 1 

```
3
3 2 4
10 9 6
450 768 517
```

Sample Output 1

```
1
4
34
```

## 第二题

![image-20191017203041352](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203041352.png)

Description

Convex Hull of a set of points, in 2D plane, is a convex polygon with minimum area such that each point lies either on the boundary of polygon or inside it. Now given a set of points the task is to find the convex hull of points.

Input

The first line of input contains an integer T denoting the no of test cases. Then T test cases follow. Each test case contains an integer N denoting the no of points. Then in the next line are N*2 space separated values denoting the points ie x and y.Constraints:1<=T<=100,1<=N<=100,1<=x,y<=1000

Output

For each test case in a new line print the points x and y of the convex hull separated by a space in sorted order (increasing by x first, then by y) where every pair is separated from the other by a ','. If no convex hull is possible print -1.

Sample Input 1 

```
2
3
1 2 3 1 5 6
3
1 2 4 4 5 1
```

Sample Output 1

```
1 2, 3 1, 5 6
1 2, 4 4, 5 1
```

## 第三题

![image-20191017203112268](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203112268.png)

Description

Dilpreet wants to paint his dog- Buzo's home that has n boards with different lengths[A1, A2,..., An]. He hired k painters for this work and each painter takes 1 unit time to paint 1 unit of the board.The problem is to find the minimum time to get this job done under the constraints that any painter will only paint continuous sections of boards, say board {2, 3, 4} or only board {1} or nothing but not board {2, 4, 5}.

Constraints:1<=T<=100,1<=k<=30,1<=n<=50,1<=A[i]<=500

Input

The first line consists of a single integer T, the number of test cases. For each test case, the first line contains an integer k denoting the number of painters and integer n denoting the number of boards. Next line contains n- space separated integers denoting the size of boards.

Output

For each test case, the output is an integer displaying the minimum time for painting that house.

Sample Input 1 

```
2
2 4
10 10 10 10
2 4
10 20 30 40
```

Sample Output 1

```
20
60
```

## 第四题

![image-20191017203137964](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203137964.png)

Description

Find the count of numbers less than N having exactly 9 divisors

1<=T<=1000,1<=N<=10^12

Input

First Line of Input contains the number of testcases. Only Line of each testcase contains the number of members N in the rival gang.

Output

Print the desired output.

Sample Input 1 

```
2
40
5
```

Sample Output 1

```
1
0
```

#第二次课堂测验（B班）

##第一题

![image-20191017203239531](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203239531.png)

Description

They declared Sonam as bewafa. Although she is not, believe me! She asked a number of queries to people regrading their position in a test. Now its your duty to remove her bewafa tag by answering simple queries. All the students who give test can score from 1 to 10^18. Lower the marks, better the rank. Now instead of directly telling the marks of student they have been assigned groups where marks are distributed in continuous intervals, you have been given l(i) lowest mark of interval i and r(i) highest marks in interval i. So marks distribution in that interval is given as l(i), l(i)+1, l(i)+2 . . . r(i)

Now Sonam ask queries in which she gives rank of the student (x) and you have to tell marks obtained by that student

Note: rank1 is better than rank2 and rank2 is better than rank3 and so on and the first interval starts from 1.

Constraints:1<=T<=50,1<=N<=10^5,1<=Q<=10^5,1<= l(i) < r(i) <=10^18,1<=x<=10^18

Input

The first line of input contains an integer T, denoting the no of test cases. Then T test cases follow. Each test case contains two space separated values N and Q denoting the no of groups and number of queries asked respectively. The next line contains N group of two integers separated by space which shows lowest marks in group i ie l(i) and highest marks in group i ie r(i) such that if i < j then r(i) < l(j). The next lines contain Q space separated integers x, denoting rank of student.

Output

For each query output marks obtain by student whose rank is x(1<=x<=10^18).

Sample Input 1 

```
1
3 3
1 10 12 20 22 30
5 15 25
```

Sample Output 1

```
5 16 27
```

## 第二题

![image-20191017203319005](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203319005.png)

Description



Given n Magnets which are placed linearly, with each magnet to be considered as of point object. Each magnet suffers force from its left sided magnets such that they repel it to the right and vice versa. All forces are repulsive. The force being equal to the distance (1/d , d being the distance). Now given the positions of the magnets, the task to find all the points along the linear line where net force is ZERO.

Note: Distance have to be calculated with precision of 0.0000000000001.

Constraints:1<=T<=100,1<=N<=100,1<=M[]<=1000

Input

The first line of input contains an integer T denoting the no of test cases. Then T test cases follow. The second line of each test case contains an integer N. Then in the next line are N space separated values of the array M[], denoting the positions of the magnet.

Output

For each test case in a new line print the space separated points having net force zero till precised two decimal places.

Sample Input 1 

```
2
2
1 2 
4
0 10 20 30 
```

Sample Output 1

```
1.50
3.82 15.00 26.18
```

## 第三题

![image-20191017203423974](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203423974.png)

Description

You are given N number of books. Every ith book has Pi number of pages. You have to allocate books to M number of students. There can be many ways or permutations to do so. In each permutation one of the M students will be allocated the maximum number of pages. Out of all these permutations, the task is to find that particular permutation in which the maximum number of pages allocated to a student is minimum of those in all the other permutations, and print this minimum value. Each book will be allocated to exactly one student. Each student has to be allocated atleast one book.

Input

The first line contains 'T' denoting the number of testcases. Then follows description of T testcases:Each case begins with a single positive integer N denoting the number of books.The second line contains N space separated positive integers denoting the pages of each book.And the third line contains another integer M, denoting the number of studentsConstraints:1<= T <=70，1<= N <=50，1<= A [ i ] <=250，1<= M <=50，Note: Return -1 if a valid assignment is not possible, and allotment should be in contiguous order (see explanation for better understanding)

Output

For each test case, output a single line containing minimum number of pages each student has to read for corresponding test case.

Sample Input 1 

```
1
4
12 34 67 90
2
```

Sample Output 1

```
113
```

## 第四题

![image-20191017203452737](/Users/zhangye/Library/Application Support/typora-user-images/image-20191017203452737.png)

Description

There are Infinite People Standing in a row, indexed from 1.A person having index 'i' has strength of (i*i).You have Strength 'P'. You need to tell what is the maximum number of People You can Kill With your Strength P.You can only Kill a person with strength 'X' if P >= 'X' and after killing him, Your Strength decreases by 'X'.

Input

First line contains an integer 'T' - the number of testcases,Each of the next 'T' lines contains an integer 'P'- Your Power.Constraints:1<=T<=100001<=P<=1000000000000000

Output

For each testcase Output The maximum Number of People You can kill.

Sample Input 1 

```
1
14
```

Sample Output 1

```
3
```

# 第二次作业

###1、

![image-20191031095915812](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031095915812.png)



### 2、

![image-20191031095946859](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031095946859.png)

###3、

![image-20191031095958983](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031095958983.png)

### 4、

![image-20191031100009067](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100009067.png)

###5、

![image-20191031100020559](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100020559.png)

### 6、

![image-20191031100031045](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100031045.png)

### 7、

![image-20191031100042004](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100042004.png)

###8、

![image-20191031100051286](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100051286.png)

# 第三次测验（A班）

字符串/数字

###1、



![image-20191031100235486](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100235486.png)

Description

Given a string ‘str’ of digits, find length of the longest substring of ‘str’, such that the length of the substring is 2k digits and sum of left k digits is equal to the sum of right k digits.

Input

输入第一行是测试用例的个数，后面每一行表示一个数字组成的字符串，例如："123123"

Output

输出找到的满足要求的最长子串的长度。例如，给定的例子长度应该是 6。每行对应一个用例的结果。

Sample Input 1 

```
1
1538023
```

Sample Output 1

```
4
```

### 2、

![image-20191031100545331](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100545331.png)

Description

Given an array of positive integers and many queries for divisibility. In every query Q[i], we are given an integer K , we need to count all elements in the array which are perfectly divisible by K.

Constraints:1<=T<=1001<=N,M<=1051<=A[i],Q[i]<=105

Input

The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case consists of three lines. First line of each test case contains two integers N & M, second line contains N space separated array elements and third line contains M space separated queries.

Output

For each test case,In new line print the required count for each query Q[i].

Sample Input 1 

```
2
6 3
2 4 9 15 21 20
2 3 5
3 2
3 4 6
2 3
```

Sample Output 1

```
3 3 2
2 2
```

### 3、

![image-20191031100310288](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100310288.png)

Description



Consider a string A = "12345". An infinite string s is built by performing infinite steps on A recursively. In i-th step, A is concatenated with ‘$’ i times followed by reverse of A. A=A|$...$|reverse(A), where | denotes concatenation.

Constraints:1<=Q<=10^5, 1<=POS<=10^12

Input

输入第一行为查询次数，后面为每次查询的具体字符位置。

Output

输出每一次查询位置上的字符。

Sample Input 1 

```
2
3
10
```

Sample Output 1

```
3
2
```

### 4、

![image-20191031100328451](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100328451.png)

Description

Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n > m.

Input

输入第一行是用例个数，后面一行表示一个用例；用例包括两部分，第一部分为给定文本，第二部分为搜索串，两部分使用","隔开。

Output

每一个用例输出一行，每行按照找到的位置先后顺序排列，使用空格隔开。

Sample Input 1 

```
2
THIS IS A TEST TEXT,TEST
AABAACAADAABAABA,AABA
```

Sample Output 1

```
10
0 9 12
```

### 5、![image-20191031100355545](/Users/zhangye/Library/Application Support/typora-user-images/image-20191031100355545.png)

Description

Cows in the FooLand city are interesting animals. One of their specialties is related to producing offsprings. A cow in FooLand produces its first calve (female calf) at the age of two years and proceeds to produce other calves (one female calf a year).

Now the farmer Harold wants to know how many animals would he have at the end of N years, if we assume that none of the calves die, given that initially, he has only one female calf?

explanation:At the end of 1 year, he will have only 1 cow, at the end of 2 years he will have 2 animals (one parent cow C1 and other baby calf B1 which is the offspring of cow C1).At the end of 3 years, he will have 3 animals (one parent cow C1 and 2 female calves B1 and B2, C1 is the parent of B1 and B2).At the end of 4 years, he will have 5 animals (one parent cow C1, 3 offsprings of C1 i.e. B1, B2, B3 and one offspring of B1).

Input

The first line contains a single integer T denoting the number of test cases. Each line of the test case contains a single integer N as described in the problem.

Output

For each test case print in new line the number of animals expected at the end of N years modulo 10^9 + 7.

Sample Input 1 

```
2
2
4
```

Sample Output 1

```
2
5
```



# 第三次作业

![image-20191201200026294](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200026294.png)

分配问题

Description



对给定的n个任务与n个人之间的成本矩阵完成成本最低的任务分配策略。



Input



输入：第一行为用例个数，之后为每一个用例；用例的第一行为任务个数，即n；用例的第二行为使用逗号隔开的人员完成任务的成本；每一个成本描述包括人员序号、任务序号和成本，使用空格隔开。人员序号和任务序号都是从1到n的整数，序号出现的次序没有固定规则。



Output



输出：每一个用例输出一行，从序号为1的人员开始，给出其分配的任务序号，使用空格隔开；使用逗号将多个解隔开。结果按照人员分配的任务序号大小排，第一个人员的任务序号大的放在前面，如果相同则看第二个人员的任务，以此类推。



Sample Input 1 

```
1
4
2 1 6,1 2 2,1 3 7,1 4 8,1 1 9,2 2 4,2 3 3,2 4 7,3 1 5,3 2 8,3 3 1,3 4 8,4 1 7,4 2 6,4 3 9,4 4 4
```

Sample Output 1

```
2 1 3 4
```



![image-20191201200053151](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200053151.png)、KD树构造和查找

Description



对给定的点集合构造KD树，要求如下：将方差最大的维度作为当前的分割维度，将数据集在分割维度上排序后的中位数作为分割点。程序要检索给定点对应的最近的K个点的坐标。



Input



输入第一行为测试用例个数，后面为测试用例，每一个用例包含三行，第一行为点集合（点之间用逗号隔开，两个坐标用空格隔开），第二行为检索的点，第三行为K值。



Output



输出每一个用例的最近K个点，按照距离从小到大的顺序打印。



Sample Input 1 

```
1
3 5,6 2,5 8,9 3,8 6,1 1,2 9
8.2 4.6
2
```

Sample Output 1

```
8 6,9 3
```

![image-20191201200110758](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200110758.png)

实现Shell排序

Description



实现Shell排序，对给定的无序数组，按照给定的间隔变化（间隔大小即同组数字index的差），打印排序结果，注意不一定是最终排序结果！



Input



输入第一行表示测试用例个数，后面为测试用例，每一个用例有两行，第一行为给定数组，第二行为指定间隔，每一个间隔用空格隔开。



Output



输出的每一行为一个用例对应的指定排序结果。



Sample Input 1 

```
1
49 38 65 97 76 13 27 49 55 4
5 3
```

Sample Output 1

```
13 4 49 38 27 49 55 65 97 76
```

![image-20191201200131843](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200131843.png)

棋盘覆盖问题

Description



棋盘覆盖问题：给定一个大小为2^n2^n个小方格的棋盘，其中有一个位置已经被填充，现在要用一个L型（22个小方格组成的大方格中去掉其中一个小方格）形状去覆盖剩下的小方格。求出覆盖方案，即哪些坐标下的小方格使用同一个L型格子覆盖。注意：坐标从0开始。左上方的第一个格子坐标为(0,0)，第一行第二个坐标为(0,1)，第二行第一个为(1,0)，以此类推。



Input



输入第一行为测试用例个数，后面每一个用例有两行，第一行为n值和特殊的格子的坐标（用空格隔开），第二行为需要查找其属于同一个L型格子的格子坐标。



Output



输出每一行为一个用例的解，先按照行值从小到大、再按照列值从小到大的顺序输出每一个用例的两个坐标；用逗号隔开。



Sample Input 1 

```
1
1 1 1
0 0
```

Sample Output 1

```
0 1,1 0
```



![image-20191201200150603](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200150603.png)

深度优先遍历

Description



按照给定的起始顶点深度优先遍历给定的无向图，尝试所有可能的遍历方式，打印遍历过程中出现的最大深度。



Input



输入第一行是用例个数，后面每个用例使用多行表示，用例的第一行是图中节点的个数n和起始点，用空格隔开，后面n+1行为图的邻接矩阵，其中第一行为节点名称。值之间使用空格隔开。



Output



输出深度优先遍历中遇到的最大深度。



Sample Input 1 

```
1
4 a
a b c d
a 0 1 1 0
b 1 0 1 0
c 1 1 0 1
d 0 0 1 0
```

Sample Output 1

```
4
```

![image-20191201200217592](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200217592.png)

广度优先遍历图

Description



按照给定的起始顶点广度优先遍历图，每一次通过字母顺序选择顶点查找下一层邻接点，打印遍历顺序。



Input



输入第一行为测试用例个数，后面每一个用例用多行表示，用例第一行是节点个数n和开始顶点，用空格隔开，后面n+1行为图的邻接矩阵，其中第一行为节点名称。值之间使用空格隔开。



Output



输出遍历顺序，用空格隔开



Sample Input 1 

```
1
4 a
a b c d
a 0 1 1 0
b 1 0 1 0
c 1 1 0 1
d 0 0 1 0
```

Sample Output 1

```
a b c d
```

![image-20191201200234045](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200234045.png)

拓扑排序解的个数

Description



给定有向无环图中所有边，计算图的拓扑排序解的个数。



Input



输入第一行为用例个数，后面每一行表示一个图中的所有边，边的起点和终点用空格隔开，边之间使用逗号隔开。



Output



输出拓扑排序解的个数。



Sample Input 1 

```
1
a c,b c,c d,d e,d f,e g,f g
```

Sample Output 1

```
4
```



![image-20191201200256509](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201200256509.png)

按照数值个数排序

Description



对给定数组中的元素按照元素出现的次数排序，出现次数多的排在前面，如果出现次数相同，则按照数值大小排序。例如，给定数组为{2, 3, 2, 4, 5, 12, 2, 3, 3, 3, 12}，则排序后结果为{3, 3, 3, 3, 2, 2, 2, 12, 12, 4, 5}。



Input



输入的第一行为用例个数；后面每一个用例使用两行表示，第一行为数组长度，第二行为数组内容，数组元素间使用空格隔开。



Output



每一个用例的排序结果在一行中输出，元素之间使用空格隔开。



Sample Input 1 

```
1
4
2 3 2 5
```

Sample Output 1

```
2 2 3 5
```



# 第四次课堂测验A班



###1、数组查询

![image-20191121093547111](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121093547111.png)

数组查询

Description



Given an array, the task is to complete the function which finds the maximum sum subarray, where you may remove at most one element to get the maximum sum.



Input



第一行为测试用例个数T；后面每两行表示一个用例，第一行为用例中数组长度N，第二行为数组具体内容。



Output



每一行表示对应用例的结果。



Sample Input 1 

```
1
5
1 2 3 -4 5
```

Sample Output 1

```
11
```

Hint

```
例如，对一个数组A[] = {1, 2, 3, -4, 5}，要移除-4得到最大和的子数组，和为11.
```



### 2、订单问题

![image-20191121093704299](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121093704299.png)

Description



Rahul and Ankit are the only two waiters in Royal Restaurant. Today, the restaurant received N orders. The amount of tips may differ when handled by different waiters, if Rahul takes the ith order, he would be tipped Ai rupees and if Ankit takes this order, the tip would be Bi rupees.In order to maximize the total tip value they decided to distribute the order among themselves. One order will be handled by one person only. Also, due to time constraints Rahul cannot take more than X orders and Ankit cannot take more than Y orders. It is guaranteed that X + Y is greater than or equal to N, which means that all the orders can be handled by either Rahul or Ankit. Find out the maximum possible amount of total tip money after processing all the orders.



Input



• The first line contains one integer, number of test cases.

• The second line contains three integers N, X, Y.

• The third line contains N integers. The ith integer represents Ai.

• The fourth line contains N integers. The ith integer represents Bi.



Output



Print a single integer representing the maximum tip money they would receive.



Sample Input 1 

```
1
5 3 3
1 2 3 4 5
5 4 3 2 1
```

Sample Output 1

```
21
```



### 3、按照要求保留数组元素使得和最大![image-20191121093731944](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121093731944.png)

Description



Given an array of N numbers, we need to maximize the sum of selected numbers. At each step, you need to select a number Ai, delete one occurrence of Ai-1 (if exists) and Ai each from the array. Repeat these steps until the array gets empty. The problem is to maximize the sum of selected numbers.



Input



The first line of the input contains T denoting the number of the test cases. For each test case, the first line contains an integer n denoting the size of the array. Next line contains n space separated integers denoting the elements of the array.

Constraints:1<=T<=100，1<=n<=50，1<=A[i]<=20

Note: Numbers need to be selected from maximum to minimum.



Output



For each test case, the output is an integer displaying the maximum sum of selected numbers.



Sample Input 1 

```
2
3
1 2 3
6
1 2 2 2 3 4
```

Sample Output 1

```
4
10
```

### 4、如何花最少的钱购买蔬菜

![image-20191121093803146](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121093803146.png)

Description



Rahul wanted to purchase vegetables mainly brinjal, carrot and tomato. There are N different vegetable sellers in a line. Each vegetable seller sells all three vegetable items, but at different prices. Rahul, obsessed by his nature to spend optimally, decided not to purchase same vegetable from adjacent shops. Also, Rahul will purchase exactly one type of vegetable item (only 1 kg) from one shop. Rahul wishes to spend minimum money buying vegetables using this strategy. Help Rahul determine the minimum money he will spend.



Input



First line indicates number of test cases T. Each test case in its first line contains N denoting the number of vegetable sellers in Vegetable Market. Then each of next N lines contains three space separated integers denoting cost of brinjal, carrot and tomato per kg with that particular vegetable seller.



Output



For each test case, output the minimum cost of shopping taking the mentioned conditions into account in a separate line.

Constraints:1 <= T <= 101 <= N <= 100000 Cost of each vegetable(brinjal/carrot/tomato) per kg does not exceed 10^4



Sample Input 1 

```
1
3
1 50 50
50 50 50
1 50 50
```

Sample Output 1

```
52
```

![image-20191121094812734](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121094812734.png)

#第四次课堂测验B班

![image-20191121184018837](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121184018837.png)

是否能通过考试

Description



小张想要通过明天的考试。他知道考题的分值分布，也知道考试中要拿到每一个题目需要耗费的时间。假设考试时长为h，共n个题目，需要拿到p分才能通过考试。现在已知每个考题的得分与耗时，请你判断小张能否通过合理安排时间，而通过考试，并给出通过考试的最短时间。



Input



输入第一行为测试用例个数.每一个用例有若干行，第一行为任务数量n、考试时常h、通过分数p，下面的n行是每一个题目的耗时和得分。所有数值用空格分开。



Output



对每一个用例输出一行，如果能够通过考试，则输出“YES”和消耗最短时间，用空格隔开。 否则，输出“NO”。



Sample Input 1 

```
1
5 40 21 
12 10 
16 10 
20 10 
24 10 
8 3 
```

Sample Output 1

```
YES 36
```



![image-20191121184042097](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121184042097.png)

Description



Mike is a lawyer with the gift of photographic memory. He is so good with it that he can tell you all the numbers on a sheet of paper by having a look at it without any mistake. Mike is also brilliant with subsets so he thought of giving a challange based on his skill and knowledge to Rachael. Mike knows how many subset are possible in an array of N integers. The subsets may or may not have the different sum. The challenge is to find the maximum sum produced by any subset under the condition:

**The elements present in the subset should not have any digit in common.**

Note: Subset {12, 36, 45} does not have any digit in common and Subset {12, 22, 35} have digits in common.Rachael find it difficult to win the challenge and is asking your help. Can youhelp her out in winning this challenge?



Input



First Line of the input consist of an integer T denoting the number of test cases. Then T test cases follow. Each test case consist of a numbe N denoting the length of the array. Second line of each test case consist of N space separated integers denoting the array elements.

Constraints:

1 <= T <= 100

1 <= N <= 100

1 <= array elements <= 100000



Output



Corresponding to each test case, print output in the new line.



Sample Input 1 

```
1
3
12 22 35
```

Sample Output 1

```
57
```



![image-20191121184117097](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121184117097.png)

Description



Let's define a Series Whose recurrence formula is as follows :

C(n)= 3C(i-1) + 4C(i-2) + 5C(i-3) + 6C(i-4)

C(0)= 2

C(1)= 0

C(2)= 1

C(3)= 7

Now based on this Series a Matrix Mi,j of size nn is to be formed.The top left cell is(1,1) and the bottom right corner is (n,n). Each cell (i,j) of the Matrix contains either 1 or 0. If C( (i*j)^3 ) is odd, Mi,j is 1, otherwise, it's 0.Count the total number of ones in the Matrix.



Input



First Line Of the input will contain an integer 'T'- the number of test cases . Each of the next 'T' lines consists of an integer 'n'.-denoting the size of the matrix.

Constraints :

1 ≤ T ≤ 1000

1 ≤ n ≤ 1000



Output



For each test case, output a single Integer -the taste value fo the dish of size-n*n.



Sample Input 1 

```
1
2
```

Sample Output 1

```
0
```

![image-20191121184156340](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121184156340.png)

![image-20191121184207943](/Users/zhangye/Library/Application Support/typora-user-images/image-20191121184207943.png)

最小化初始点

Description



Given a grid with each cell consisting of positive, negative or no points i.e, zero points. We can move across a cell only if we have positive points ( > 0 ). Whenever we pass through a cell, points in that cell are added to our overall points. We need to find minimum initial points to reach cell (m-1, n-1) from (0, 0) by following these certain set of rules :

1.From a cell (i, j) we can move to (i+1, j) or (i, j+1).

2.We cannot move from (i, j) if your overall points at (i, j) is <= 0.

3.We have to reach at (n-1, m-1) with minimum positive points i.e., > 0.



Input



The first line contains an integer 'T' denoting the total number of test cases.In each test cases, the first line contains two integer 'R' and 'C' denoting the number of rows and column of array.
The second line contains the value of the array i.e the grid, in a single line separated by spaces in row major order.

Constraints:

1 ≤ T ≤ 30

1 ≤ R,C ≤ 10

-30 ≤ A[R][C] ≤ 30

Input: points[m][n] = { {-2, -3, 3},
{-5, -10, 1},
{10, 30, -5}
};



Output



Print the minimum initial points to reach the bottom right most cell in a separate line.

7

Explanation:
7 is the minimum value to reach destination with
positive throughout the path. Below is the path.

(0,0) -> (0,1) -> (0,2) -> (1, 2) -> (2, 2)

We start from (0, 0) with 7, we reach(0, 1)
with 5, (0, 2) with 2, (1, 2) with 5, (2, 2)with and finally we have 1 point (we needed
greater than 0 points at the end).



Sample Input 1 

```
1
3 3
-2 -3 3 -5 -10 1 10 30 -5
```

Sample Output 1

```
7
```

# 第五次课堂测验A班

贪心

![image-20191201195606168](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195606168.png)

管道网络

Description



Every house in the colony has at most one pipe going into it and at most one pipe going out of it. Tanks and taps are to be installed in a manner such that every house with one outgoing pipe but no incoming pipe gets a tank installed on its roof and every house with only an incoming pipe and no outgoing pipe gets a tap. Find the efficient way for the construction of the network of pipes.



Input



The first line contains an integer T denoting the number of test cases. For each test case, the first line contains two integer n & p denoting the number of houses and number of pipes respectively. Next, p lines contain 3 integer inputs a, b & d, d denoting the diameter of the pipe from the house a to house b.Constraints:1<=T<=50，1<=n<=20，1<=p<=50，1<=a, b<=20，1<=d<=100



Output



For each test case, the output is the number of pairs of tanks and taps installed i.e n followed by n lines that contain three integers: house number of tank, house number of tap and the minimum diameter of pipe between them.



Sample Input 1 

```
1
9 6
7 4 98
5 9 72
4 6 10
2 8 22
9 7 17
3 1 66
```

Sample Output 1

```
3
2 8 22
3 1 66
5 6 10
```

![image-20191201195635982](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195635982.png)

时间分隔

Description



Given arrival and departure times of all trains that reach a railway station. Your task is to find the minimum number of platforms required for the railway station so that no train waits. 

**Note**: Consider that all the trains arrive on the same day and leave on the same day. Also, arrival and departure times must not be same for a train.



Input



The first line of input contains T, the number of test cases. For each test case, first line will contain an integer N, the number of trains. Next two lines will consist of N space separated time intervals denoting arrival and departure times respectively. 

**Note:** Time intervals are in the 24-hourformat(hhmm), preceding zeros are insignificant. 200 means 2:00.
Consider the example for better understanding of input.

Constraints:1 <= T <= 100，1 <= N <= 1000，1 <= A[i] < D[i] <= 2359



Output



For each test case, print the minimum number of platforms required for the trains to arrive and depart safely.



Sample Input 1 

```
1
6 
900  940 950  1100 1500 1800
910 1200 1120 1130 1900 2000
```

Sample Output 1

```
3
```



![image-20191201195703285](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195703285.png)

时间与收益

Description



Given a set of n jobs where each job i has a deadline and profit associated to it. Each job takes 1 unit of time to complete and only one job can be scheduled at a time. We earn the profit if and only if the job is completed by its deadline. The task is to find the maximum profit and the number of jobs done.



Input



The first line of input contains an integer T denoting the number of test cases.Each test case consist of an integer N denoting the number of jobs and the next line consist of Job id, Deadline and the Profit associated to that Job.

Constraints:1<=T<=100，1<=N<=100，1<=Deadline<=100，1<=Profit<=500



Output



Output the number of jobs done and the maximum profit.



Sample Input 1 

```
2
4
1 4 20 2 1 10 3 1 40 4 1 30
5
1 2 100 2 1 19 3 2 27 4 1 25 5 1 15
```

Sample Output 1

```
2 60
2 127
```

![image-20191201195725434](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195725434.png)

硬币最小数量

Description



Given the list of coins of distinct denominations and total amount of money. Output the minimum number of coins required to make up that amount. Output -1 if that money cannot be made up using given coins. You may assume that there are infinite numbers of coins of each type.



Input



The first line contains 'T' denoting the number of test cases. Then follows description of test cases. Each cases begins with the two space separated integers 'n' and 'amount' denoting the total number of distinct coins and total amount of money respectively. The second line contains N space-separated integers A1, A2, ..., AN denoting the values of coins. 

Constraints:1<=T<=30，1<=n<=100，1<=Ai<=1000，1<=amount<=100000



Output



Print the minimum number of coins required to make up that amount or return -1 if it is impossible to make that amount using given coins.



Sample Input 1 

```
2
3 11
1 2 5
2 7
2 6
```

Sample Output 1

```
3
-1
```

# 第五次课堂测验B班

有两题和A班一样

![image-20191201195751180](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195751180.png)

Description



There are two parallel roads, each containing N and M buckets, respectively. Each bucket may contain some balls. The buckets on both roads are kept in such a way that they are sorted according to the number of balls in them. Geek starts from the end of the road which has the bucket with a lower number of balls(i.e. if buckets are sorted in increasing order, then geek will start from the left side of the road). The geek can change the road only at the point of intersection(which means, buckets with the same number of balls on two roads). Now you need to help Geek to collect the maximum number of balls.



Input



The first line of input contains T denoting the number of test cases. The first line of each test case contains two integers N and M, denoting the number of buckets on road1 and road2 respectively. 2nd line of each test case contains N integers, number of balls in buckets on the first road. 3rd line of each test case contains M integers, number of balls in buckets on the second road.

Constraints:1<= T <= 1000，1<= N <= 10^3，1<= M <=10^3，0<= A[i],B[i]<=10^6



Output



For each test case output a single line containing the maximum possible balls that Geek can collect.



Sample Input 1 

```
1
5 5
1 4 5 6 8
2 3 4 6 9
```

Sample Output 1

```
29
```

![image-20191201195812816](/Users/zhangye/Library/Application Support/typora-user-images/image-20191201195812816.png)

格子里的整数

Description



Given a square grid of size n, each cell of which contains integer cost which represents a cost to traverse through that cell, we need to find a path from top left cell to bottom right cell by which total cost incurred is minimum.

Note : It is assumed that negative cost cycles do not exist in input matrix.



Input



The first line of input will contain number of test cases T. Then T test cases follow . Each test case contains 2 lines. The first line of each test case contains an integer n denoting the size of the grid. Next line of each test contains a single line containing N*N space separated integers depecting cost of respective cell from (0,0) to (n,n).

Constraints:1<=T<=50，1<= n<= 50



Output



For each test case output a single integer depecting the minimum cost to reach the destination.



Sample Input 1 

```
2
5
31 100 65 12 18 10 13 47 157 6 100 113 174 11 33 88 124 41 20 140 99 32 111 41 20
2
42 93 7 14
```

Sample Output 1

```
327
63
```